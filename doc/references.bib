
@misc{noauthor_software_nodate,
	title = {Software {Foundations}},
	url = {https://softwarefoundations.cis.upenn.edu/},
	urldate = {2021-05-06},
}

@misc{noauthor_typing_nodate,
	title = {typing — {Support} for type hints — {Python} 3.9.5 documentation},
	url = {https://docs.python.org/3/library/typing.html},
	urldate = {2021-05-06},
}

@misc{noauthor_verifiable_nodate,
	title = {Verifiable {C}},
	url = {https://softwarefoundations.cis.upenn.edu/vc-current/index.html},
	urldate = {2021-05-06},
}

@article{lipton_social_1979,
	title = {Social {Processes} and {Proofs} of {Theorems} and {Programs}},
	volume = {22},
	abstract = {It is argued that formal verifications of programs, no matter how obtained, will not play the same key role in the development of computer science and software engineering as proofs do in mathematics. Furthermore the absence of continuity, the inevitability of change, and the complexity of specification of significantly many real programs make the formal verification process difficult to justify and manage. It is felt that ease of formal verification should not dominate program language design.},
	language = {en},
	number = {5},
	author = {Lipton, Richard J and Perlis, Alan J},
	year = {1979},
	pages = {10},
}

@misc{noauthor_ais_nodate,
	title = {{AIS} {Transactions} on {Replication} {Research} {\textbar} {AIS} {Journals} {\textbar} {Association} for {Information} {Systems}},
	url = {https://aisel.aisnet.org/trr/},
	urldate = {2021-05-06},
}

@misc{noauthor_rose_nodate,
	title = {{ROSE} {Festival} 2018 - {Recognizing} and {Rewarding} {Open} {Science} in {Software} {Engineering} - {ESEC}/{FSE} 2018},
	url = {https://2018.fseconference.org/track/rosefest-2018},
	abstract = {ESEC/FSE hosting a new initiative that aims to take SE research artifacts to the next level. The ROSE festival is a world-wide salute to replication and reproducibility in SE. At the time of this writing, similar events are being considered for RE’19, ICSE’19, ESEC/FSE’19 and ESEM’19. 
Our aim is to create a venue where researchers can receive public credit for facilitating and participating in open science in SE (specifically, in creating replicated and reproduced results). ROSE is needed since most current conferences only evaluate research artifacts generated by that venue’s accepted pa ...},
	urldate = {2021-05-06},
}

@misc{pradel_michaelpradeldeepbugs_2021,
	title = {michaelpradel/{DeepBugs}},
	copyright = {MIT License         ,                 MIT License},
	url = {https://github.com/michaelpradel/DeepBugs},
	abstract = {DeepBugs is a framework for learning bug detectors from an existing code corpus.},
	urldate = {2021-05-06},
	author = {Pradel, Michael},
	month = may,
	year = {2021},
	note = {original-date: 2017-11-23T10:18:25Z},
}

@misc{noauthor_publications_nodate,
	title = {Publications},
	url = {https://www.sri.inf.ethz.ch/publications/},
	abstract = {SRI Group Website},
	language = {en},
	urldate = {2021-05-06},
	journal = {Secure, Reliable, and Intelligent Systems Lab},
}

@misc{noauthor_fuzzing_2020,
	title = {Fuzzing: {Using} automated testing to identify security bugs in software},
	shorttitle = {Fuzzing},
	url = {https://www.microsoft.com/en-us/research/blog/a-brief-introduction-to-fuzzing-and-why-its-an-important-tool-for-developers/},
	abstract = {Microsoft researcher Patrice Godefroid shares some of his insights into automated testing techniques in an article for Communications of the ACM. Understand how these methods, called “fuzzing,” can boost security in software processing untrusted inputs.},
	language = {en-US},
	urldate = {2021-05-06},
	journal = {Microsoft Research},
	month = mar,
	year = {2020},
}

@article{cao_separation-logic-based_nodate,
	title = {Separation-{Logic}-{Based} {Program} {Verification} in {Coq}},
	language = {en},
	author = {Cao, Qinxiang},
	pages = {227},
}

@article{cao_separation-logic-based_nodate-1,
	title = {Separation-{Logic}-{Based} {Program} {Verification} in {Coq}},
	language = {en},
	author = {Cao, Qinxiang},
	pages = {227},
}

@misc{noauthor_higher_nodate,
	title = {Higher {Order} {Separation} {Logic}},
	url = {http://www0.cs.ucl.ac.uk/staff/p.ohearn/SeparationLogic/Separation_Logic/Higher_Order.html},
	urldate = {2021-05-06},
}

@misc{noauthor_higher_nodate-1,
	title = {Higher {Order} {Separation} {Logic}},
	url = {http://www0.cs.ucl.ac.uk/staff/p.ohearn/SeparationLogic/Separation_Logic/Higher_Order.html},
	urldate = {2021-05-06},
}

@article{beringer_abstraction_nodate,
	title = {Abstraction and {Subsumption} in {Modular} {Veriﬁcation} of {C} {Programs}},
	abstract = {Representation predicates enable data abstraction in separation logic, but when the same concrete implementation may need to be abstracted in diﬀerent ways, one needs a notion of subsumption. We demonstrate function-speciﬁcation subtyping, analogous to subtyping, with a subsumption rule: if φ is a funspec-sub of ψ, that is φ {\textless}: ψ, then x : φ implies x : ψ, meaning that any function satisfying speciﬁcation φ can be used wherever a function satisfying ψ is demanded. We extend previous notions of Hoare-logic sub-speciﬁcation, which already included parameter adaption, to include framing (necessary for separation logic) and impredicative bifunctors (necessary for higher-order functions, i.e. function pointers). We show intersection speciﬁcations, with the expected relation to subtyping. We show how this enables compositional modular veriﬁcation of the functional correctness of C programs, in Coq, with foundational machine-checked proofs of soundness.},
	language = {en},
	author = {Beringer, Lennart and Appel, Andrew W},
	pages = {19},
}

@misc{noauthor_princetonuniversityvst_2021,
	title = {{PrincetonUniversity}/{VST}},
	copyright = {View license         ,                 View license},
	url = {https://github.com/PrincetonUniversity/VST},
	abstract = {Verified Software Toolchain. Contribute to PrincetonUniversity/VST development by creating an account on GitHub.},
	urldate = {2021-05-06},
	publisher = {PrincetonUniversity},
	month = may,
	year = {2021},
	note = {original-date: 2014-11-21T21:36:24Z},
}

@book{appel_program_2014,
	address = {Cambridge},
	title = {Program {Logics} for {Certified} {Compilers}},
	isbn = {978-1-107-25655-2},
	url = {http://ebooks.cambridge.org/ref/id/CBO9781107256552},
	language = {en},
	urldate = {2021-05-06},
	publisher = {Cambridge University Press},
	author = {Appel, Andrew W. and Dockins, Robert and Hobor, Aquinas and Beringer, Lennart and Dodds, Josiah and Stewart, Gordon and Blazy, Sandrine and Leroy, Xavier},
	year = {2014},
	doi = {10.1017/CBO9781107256552},
}

@misc{noauthor_verifiable_nodate-1,
	title = {Verifiable {C}},
	url = {https://vst.cs.princeton.edu/veric/},
	urldate = {2021-05-06},
}

@misc{noauthor_verified_nodate,
	title = {Verified {Software} {Toolchain}},
	url = {https://vst.cs.princeton.edu/},
	urldate = {2021-05-06},
}

@misc{noauthor_verified_nodate-1,
	title = {Verified {Software} {Toolchain}},
	url = {https://vst.cs.princeton.edu/},
	urldate = {2021-05-06},
}

@misc{noauthor_vst_nodate,
	title = {{VST} downloads},
	url = {https://vst.cs.princeton.edu/download/},
	urldate = {2021-05-06},
}

@misc{noauthor_mechanized_nodate,
	title = {Mechanized {Semantic} {Library}},
	url = {https://vst.cs.princeton.edu/msl/LibFiles/0.3/index.html},
	urldate = {2021-05-06},
}

@article{hobor_theory_nodate,
	title = {A {Theory} of {Indirection} via {Approximation}},
	abstract = {Building semantic models that account for various kinds of indirect reference has traditionally been a difﬁcult problem. Indirect reference can appear in many guises, such as heap pointers, higher-order functions, object references, and shared-memory mutexes.},
	language = {en},
	author = {Hobor, Aquinas and Dockins, Robert and Appel, Andrew W},
	pages = {14},
}

@misc{noauthor_compcert_nodate,
	title = {{CompCert} - {Context} and motivations},
	url = {https://compcert.org/motivations.html},
	urldate = {2021-05-06},
}

@inproceedings{reynolds_separation_2002,
	address = {Copenhagen, Denmark},
	title = {Separation logic: a logic for shared mutable data structures},
	isbn = {978-0-7695-1483-3},
	shorttitle = {Separation logic},
	url = {http://ieeexplore.ieee.org/document/1029817/},
	doi = {10.1109/LICS.2002.1029817},
	abstract = {In joint work with Peter O’Hearn and others, based on early ideas of Burstall, we have developed an extension of Hoare logic that permits reasoning about low-level imperative programs that use shared mutable data structure.},
	language = {en},
	urldate = {2021-05-06},
	booktitle = {Proceedings 17th {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE Comput. Soc},
	author = {Reynolds, J.C.},
	year = {2002},
	pages = {55--74},
}

@misc{noauthor_verifiable_nodate-2,
	title = {Verifiable {C}},
	url = {https://vst.cs.princeton.edu/veric/},
	urldate = {2021-05-06},
}

@misc{noauthor_separation_nodate,
	title = {Separation {Logic} {Proofs} in {Coq}},
	url = {https://madiot.fr/sepcourse/coq/},
	urldate = {2021-05-06},
}

@misc{ohearn_separation_nodate,
	title = {Separation {Logic}},
	url = {https://cacm.acm.org/magazines/2019/2/234356-separation-logic/fulltext?mobile=true?mobile=false},
	abstract = {Separation logic is a key development in formal reasoning about programs, opening up new lines of attack on longstanding problems.},
	language = {en},
	urldate = {2021-05-06},
	author = {O'Hearn, Peter},
}

@misc{noauthor_iris_nodate,
	title = {Iris {Project}},
	url = {https://iris-project.org/},
	urldate = {2021-05-06},
}

@misc{noauthor_seplog_nodate,
	title = {Seplog},
	url = {http://www.nongnu.org/seplog/},
	urldate = {2021-05-06},
}

@article{mansky_automating_nodate,
	title = {Automating {Separation} {Logic} for {Concurrent} {C} {Minor}},
	abstract = {In this paper, I demonstrate the implementation of several tools for program analysis in a machine-checked environment. I begin by detailing the implementation of the separation logic for Concurrent C Minor proposed by Hobor, Appel, and Nardelli in the Coq proof assistant. Formalizing the syntax and semantics of CCm and extending the set of semi-automated tactics in the base implementation of C Minor leads to a framework for building proofs of the correctness and safety of concurrent programs. I then describe a thread-modular shape analysis algorithm proposed by Gotsman et al. for inferring lock invariants in concurrent programs, and demonstrate its use as a transformation from a simple C-like language to proved-correct CCm. By reinterpreting the analysis in terms of the application of the rules of concurrent separation logic, I prove its soundness without resorting to lattice theory. Finally, I explain a two-part algorithm, based on the analysis and implemented in Coq, for the construction of CCm programs and proofs of safety from programs in the source language of the analysis.},
	language = {en},
	author = {Mansky, William},
	pages = {33},
}

@article{dockins_multimodal_2008,
	title = {Multimodal {Separation} {Logic} for {Reasoning} {About} {Operational} {Semantics}},
	volume = {218},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066108003964},
	doi = {10.1016/j.entcs.2008.10.002},
	abstract = {We show how to reason, in the proof assistant Coq, about realistic programming languages using a combination of separation logic and heterogeneous multimodal logic. A heterogeneous multimodal logic is a logic with several modal operators that are not required to satisfy the same frame conditions. The result is a powerful and elegant system for reasoning about programming languages and their semantics. The techniques are quite general and can be adopted to a wide variety of settings.},
	language = {en},
	urldate = {2021-05-06},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Dockins, Robert and Appel, Andrew W. and Hobor, Aquinas},
	month = oct,
	year = {2008},
	pages = {5--20},
}

@article{beringer_relational_nodate,
	title = {Relational program logics in decomposed style},
	abstract = {Suppose you have developed a Hoare logic for your favorite programming language. You have justiﬁed the logic by deﬁning an operational model of the language and constructing a soundness proof that interprets triples as partial correctness assertions. Now you want to interpret program analyses, validate security properties such as noninterference, or justify program transformations. You observe that all these properties are relational: they are naturally phrased over pairs of executions, for programs that are either identical or closely related. Is your program logic up to the task? This article shows how to formally decompose terminationinsensitive relational program logics into judgements from unary logics. We develop relational predicate transformers, present laws that govern their decomposition along the phrase structure, and relate them to their unary counterparts. We apply our ﬁndings to justify variants of Benton’s Relational Hoare Logic (RHL) for a language with objects, extend the logics to auxiliary state, derive a noninterference analysis in the style of Banerjee-Naumann, and develop relational interpretations of separation logic. As related executions do not have to refer to the same program syntax or employ the same notion of state, decomposition can in principle be applied to cross-language veriﬁcation problems, as long as suitable one-execution logics exist.},
	language = {en},
	author = {Beringer, Lennart},
	pages = {12},
}

@misc{noauthor_compositional_nodate,
	title = {Compositional {CompCert} {\textbar} {ACM} {SIGPLAN} {Notices}},
	url = {https://dl.acm.org/doi/10.1145/2775051.2676985},
	urldate = {2021-05-06},
}

@inproceedings{appel_modular_2016,
	address = {Lisbon},
	title = {Modular {Verification} for {Computer} {Security}},
	isbn = {978-1-5090-2607-4},
	url = {https://ieeexplore.ieee.org/document/7536361/},
	doi = {10.1109/CSF.2016.8},
	abstract = {For many software components, it is useful and important to verify their security. This can be done by an analysis of the software itself, or by isolating the software behind a protection mechanism such as an operating system kernel (virtual-memory protection) or cryptographic authentication (don’t accepted untrusted inputs). But the protection mechanisms themselves must then be veriﬁed not just for safety but for functional correctness. Several recent projects have demonstrated that formal, deductive functional-correctness veriﬁcation is now possible for kernels, crypto, and compilers. Here I explain some of the modularity principles that make these veriﬁcations possible.},
	language = {en},
	urldate = {2021-05-06},
	booktitle = {2016 {IEEE} 29th {Computer} {Security} {Foundations} {Symposium} ({CSF})},
	publisher = {IEEE},
	author = {Appel, Andrew W.},
	month = jun,
	year = {2016},
	pages = {1--8},
}

@incollection{chang_bringing_2017,
	address = {Cham},
	title = {Bringing {Order} to the {Separation} {Logic} {Jungle}},
	volume = {10695},
	isbn = {978-3-319-71236-9 978-3-319-71237-6},
	url = {http://link.springer.com/10.1007/978-3-319-71237-6_10},
	abstract = {Research results from so-called “classical” separation logics are not easily ported to so-called “intuitionistic” separation logics, and vice versa. Basic questions like, “Can the frame rule be proved independently of whether the programming language is garbage-collected?” “Can amortized resource analysis be ported from one separation logic to another?” should be straightforward. But they are not. Proofs done in a particular separation logic are diﬃcult to generalize. We argue that this limitation is caused by incompatible semantics. For example, emp sometimes holds everywhere and sometimes only on units.},
	language = {en},
	urldate = {2021-05-06},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Cao, Qinxiang and Cuellar, Santiago and Appel, Andrew W.},
	editor = {Chang, Bor-Yuh Evan},
	year = {2017},
	doi = {10.1007/978-3-319-71237-6_10},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {190--211},
}

@misc{noauthor_verifiable_nodate-3,
	title = {Verifiable {C}},
	url = {https://vst.cs.princeton.edu/veric/},
	urldate = {2021-05-06},
}

@article{hobor_theory_nodate-1,
	title = {A {Theory} of {Indirection} via {Approximation}},
	abstract = {Building semantic models that account for various kinds of indirect reference has traditionally been a difﬁcult problem. Indirect reference can appear in many guises, such as heap pointers, higher-order functions, object references, and shared-memory mutexes.},
	language = {en},
	author = {Hobor, Aquinas and Dockins, Robert and Appel, Andrew W},
	pages = {14},
}

@incollection{hutchison_fresh_2009,
	address = {Berlin, Heidelberg},
	title = {A {Fresh} {Look} at {Separation} {Algebras} and {Share} {Accounting}},
	volume = {5904},
	isbn = {978-3-642-10671-2 978-3-642-10672-9},
	url = {http://link.springer.com/10.1007/978-3-642-10672-9_13},
	abstract = {Separation Algebras serve as models of Separation Logics; Share Accounting allows reasoning about concurrent-read/exclusive-write resources in Separation Logic. In designing a Concurrent Separation Logic and in mechanizing proofs of its soundness, we found previous axiomatizations of separation algebras and previous systems of share accounting to be useful but ﬂawed. We adjust the axioms of separation algebras; we demonstrate an operator calculus for constructing new separation algebras; we present a more powerful system of share accounting with a new, simple model; and we provide a reusable Coq development.},
	language = {en},
	urldate = {2021-05-06},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Dockins, Robert and Hobor, Aquinas and Appel, Andrew W.},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Hu, Zhenjiang},
	year = {2009},
	doi = {10.1007/978-3-642-10672-9_13},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {161--177},
}

@misc{noauthor_mechanized_nodate-1,
	title = {Mechanized {Semantic} {Library}},
	url = {https://vst.cs.princeton.edu/msl/},
	urldate = {2021-05-06},
}

@incollection{hutchison_verified_2012,
	address = {Berlin, Heidelberg},
	title = {Verified {Software} {Toolchain}},
	volume = {7226},
	isbn = {978-3-642-28890-6 978-3-642-28891-3},
	url = {http://link.springer.com/10.1007/978-3-642-28891-3_2},
	abstract = {The software toolchain includes static analyzers to check assertions about programs; optimizing compilers to translate programs to machine language; operating systems and libraries to supply context for programs. Our Veriﬁed Software Toolchain veriﬁes with machine-checked proofs that the assertions claimed at the top of the toolchain really hold in the machine-language program, running in the operating-system context, on a weakly-consistent-shared-memory machine.},
	language = {en},
	urldate = {2021-05-06},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer Berlin Heidelberg},
	author = {Appel, Andrew W.},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Goodloe, Alwyn E. and Person, Suzette},
	year = {2012},
	doi = {10.1007/978-3-642-28891-3_2},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {2--2},
}

@misc{noauthor_vst_nodate-1,
	title = {{VST} downloads},
	url = {https://vst.cs.princeton.edu/download/},
	urldate = {2021-05-06},
}

@incollection{drossopoulou_oracle_2008,
	address = {Berlin, Heidelberg},
	title = {Oracle {Semantics} for {Concurrent} {Separation} {Logic}},
	volume = {4960},
	isbn = {978-3-540-78738-9 978-3-540-78739-6},
	url = {http://link.springer.com/10.1007/978-3-540-78739-6_27},
	abstract = {We deﬁne (with machine-checked proofs in Coq) a modular operational semantics for Concurrent C minor—a language with shared memory, spawnable threads, and ﬁrst-class locks. By modular we mean that one can reason about sequential control and data-ﬂow knowing almost nothing about concurrency, and one can reason about concurrency knowing almost nothing about sequential control and data-ﬂow constructs. We present a Concurrent Separation Logic with ﬁrst-class locks and threads, and prove its soundness with respect to the operational semantics. Using our modularity principle, we proved the sequential C.S.L. rules (those inherited from sequential Separation Logic) simply by adapting Appel \& Blazy’s machine-checked soundness proofs. Our Concurrent C minor operational semantics is designed to connect to Leroy’s optimizing (sequential) C minor compiler; we propose our modular semantics as a way to adapt Leroy’s compiler-correctness proofs to the concurrent setting. Thus we will obtain end-to-end proofs: the properties you prove in Concurrent Separation Logic will be true of the program that actually executes on the machine.},
	language = {en},
	urldate = {2021-05-06},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hobor, Aquinas and Appel, Andrew W. and Nardelli, Francesco Zappa},
	editor = {Drossopoulou, Sophia},
	year = {2008},
	doi = {10.1007/978-3-540-78739-6_27},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {353--367},
}

@misc{noauthor_compcert_nodate-1,
	title = {{CompCert} - {Context} and motivations},
	url = {https://compcert.org/motivations.html},
	urldate = {2021-05-06},
}

@misc{noauthor_compcert_nodate-2,
	title = {{CompCert} - {Research} objectives},
	url = {https://compcert.org/research.html},
	urldate = {2021-05-06},
}

@misc{noauthor_compcert_nodate-3,
	title = {The {CompCert} verified compiler},
	url = {https://compcert.org/doc/index.html},
	urldate = {2021-05-06},
}

@misc{noauthor_compcert_nodate-4,
	title = {{CompCert} - {The} {CompCert} {C} compiler},
	url = {https://compcert.org/compcert-C.html#subset},
	urldate = {2021-05-06},
}

@misc{noauthor_compcert_nodate-5,
	title = {{CompCert} - {The} {CompCert} {C} compiler},
	url = {https://compcert.org/compcert-C.html},
	urldate = {2021-05-06},
}

@misc{noauthor_verifiable_nodate-4,
	title = {Verifiable {C}},
	url = {https://softwarefoundations.cis.upenn.edu/vc-current/index.html},
	urldate = {2021-05-06},
}

@article{hobor_theory_nodate-2,
	title = {A {Theory} of {Indirection} via {Approximation}},
	abstract = {Building semantic models that account for various kinds of indirect reference has traditionally been a difﬁcult problem. Indirect reference can appear in many guises, such as heap pointers, higher-order functions, object references, and shared-memory mutexes.},
	language = {en},
	author = {Hobor, Aquinas and Dockins, Robert and Appel, Andrew W},
	pages = {14},
}

@incollection{hutchison_fresh_2009-1,
	address = {Berlin, Heidelberg},
	title = {A {Fresh} {Look} at {Separation} {Algebras} and {Share} {Accounting}},
	volume = {5904},
	isbn = {978-3-642-10671-2 978-3-642-10672-9},
	url = {http://link.springer.com/10.1007/978-3-642-10672-9_13},
	abstract = {Separation Algebras serve as models of Separation Logics; Share Accounting allows reasoning about concurrent-read/exclusive-write resources in Separation Logic. In designing a Concurrent Separation Logic and in mechanizing proofs of its soundness, we found previous axiomatizations of separation algebras and previous systems of share accounting to be useful but ﬂawed. We adjust the axioms of separation algebras; we demonstrate an operator calculus for constructing new separation algebras; we present a more powerful system of share accounting with a new, simple model; and we provide a reusable Coq development.},
	language = {en},
	urldate = {2021-05-06},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Dockins, Robert and Hobor, Aquinas and Appel, Andrew W.},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Hu, Zhenjiang},
	year = {2009},
	doi = {10.1007/978-3-642-10672-9_13},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {161--177},
}

@misc{noauthor_princetonuniversityvst_2021-1,
	title = {{PrincetonUniversity}/{VST}},
	copyright = {View license         ,                 View license},
	url = {https://github.com/PrincetonUniversity/VST},
	abstract = {Verified Software Toolchain. Contribute to PrincetonUniversity/VST development by creating an account on GitHub.},
	urldate = {2021-05-06},
	publisher = {PrincetonUniversity},
	month = may,
	year = {2021},
	note = {original-date: 2014-11-21T21:36:24Z},
}

@article{berger_impact_2019,
	title = {On the {Impact} of {Programming} {Languages} on {Code} {Quality}},
	volume = {41},
	issn = {0164-0925, 1558-4593},
	url = {http://arxiv.org/abs/1901.10220},
	doi = {10.1145/3340571},
	abstract = {This paper is a reproduction of work by Ray et al. which claimed to have uncovered a statistically significant association between eleven programming languages and software defects in projects hosted on GitHub. First we conduct an experimental repetition, repetition is only partially successful, but it does validate one of the key claims of the original work about the association of ten programming languages with defects. Next, we conduct a complete, independent reanalysis of the data and statistical modeling steps of the original study. We uncover a number of flaws that undermine the conclusions of the original study as only four languages are found to have a statistically significant association with defects, and even for those the effect size is exceedingly small. We conclude with some additional sources of bias that should be investigated in follow up work and a few best practice recommendations for similar efforts.},
	number = {4},
	urldate = {2021-05-06},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Berger, Emery D. and Hollenbeck, Celeste and Maj, Petr and Vitek, Olga and Vitek, Jan},
	month = dec,
	year = {2019},
	note = {arXiv: 1901.10220},
	keywords = {Computer Science - Software Engineering},
	pages = {1--24},
}

@article{ray_large_nodate,
	title = {A {Large} {Scale} {Study} of {Programming} {Languages} and {Code} {Quality} in {Github}},
	abstract = {What is the effect of programming languages on software quality? This question has been a topic of much debate for a very long time. In this study, we gather a very large data set from GitHub (729 projects, 80 Million SLOC, 29,000 authors, 1.5 million commits, in 17 languages) in an attempt to shed some empirical light on this question. This reasonably large sample size allows us to use a mixed-methods approach, combining multiple regression modeling with visualization and text analytics, to study the effect of language features such as static v.s. dynamic typing, strong v.s. weak typing on software quality. By triangulating ﬁndings from different methods, and controlling for confounding effects such as team size, project size, and project history, we report that language design does have a signiﬁcant, but modest effect on software quality. Most notably, it does appear that strong typing is modestly better than weak typing, and among functional languages, static typing is also somewhat better than dynamic typing. We also ﬁnd that functional languages are somewhat better than procedural languages. It is worth noting that these modest effects arising from language design are overwhelmingly dominated by the process factors such as project size, team size, and commit size. However, we hasten to caution the reader that even these modest effects might quite possibly be due to other, intangible process factors, e.g., the preference of certain personality types for functional, static and strongly typed languages.},
	language = {en},
	author = {Ray, Baishakhi and Posnett, Daryl and Filkov, Vladimir and Devanbu, Premkumar},
	pages = {11},
}

@misc{noauthor_opam_nodate,
	title = {opam - opam},
	url = {https://opam.ocaml.org/},
	urldate = {2021-05-06},
}

@article{donato_quicker_2014,
	series = {Selected {Papers} from the 2012 {NETL} {Multiphase} {Flow} {Workshop}},
	title = {{QUICKER}: {Quantifying} {Uncertainty} {In} {Computational} {Knowledge} {Engineering} {Rapidly}—{A} rapid methodology for uncertainty analysis},
	volume = {265},
	issn = {0032-5910},
	shorttitle = {{QUICKER}},
	url = {https://www.sciencedirect.com/science/article/pii/S0032591014000370},
	doi = {10.1016/j.powtec.2014.01.028},
	abstract = {Most engineering systems have some degree of uncertainty in their input parameters, either of a stochastic nature or on account of a lack of complete information. The interaction of these uncertain input parameters, and the propagation of uncertainty through engineering systems, lead to the stochastic nature of the system performance and outputs. Quantifying the uncertainty in an experiment or computational simulation requires sampling over the uncertain range of input parameters and propagating the uncertainty through a computational model or experiment to quantify the output parameter uncertainty. Conventional direct sampling methods for input uncertainty propagation, such as Monte Carlo sampling or Latin Hypercube sampling, require a very large number of samples for convergence of the statistical parameters, such as mean and standard deviation, and can be prohibitively time-consuming. This computational tedium has been partially eliminated through the use of meta-models, which approximate a computational simulation or experiment via a response surface, but the computational time savings from these models are limited to systems with a small number of uncertain input parameters. Toward addressing the challenge of input uncertainty propagation, this paper presents a new uncertainty analysis methodology, QUICKER: Quantifying Uncertainty In Computational Knowledge Engineering Rapidly, that can reduce sample sizes by orders of magnitude while still maintaining comparable accuracy to direct sampling methods. In this paper, the QUICKER methodology is described and demonstrated with both analytical and computational scenarios.},
	language = {en},
	urldate = {2021-04-08},
	journal = {Powder Technology},
	author = {Donato, A. and Pitchumani, R.},
	month = oct,
	year = {2014},
	keywords = {Gaussian process, Input uncertainty propagation, Latin hypercube sampling, QUICKER, Radial basis function,, Uncertainty quantification},
	pages = {54--65},
}
