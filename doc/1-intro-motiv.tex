\section{Introduction and Motivation}
\label{sec:introduction}


The practical benefits of being able to prove the correctness of C programs are in the usefulness of C programs in areas requiring high levels of software security and safety critical software. C is not like other garbage collector optional languages like Ada. C uses a lot of undefined behavior to make compilers easier to implement across hardware platforms. But C was designed to be used to port and maintain the Unix operating system. With the wide spread of Unix and Unix-like operating systems, and C's adoption into spaces that used to be reserved for assemblers, C is now a very common component in modern computer architecture.


In large programs, such as server file systems, bugs seem to take on an analytical property. I mean from the field of mathematical analysis. Given more time and effort, there always seems to be a new bug. It is as if software bugs continuously approach a neighborhood of zero bugs. But verification of software is appealing due to the potential for internal consistency of a program. Random acts of physics on the hardware might still be a concern, or maybe we proved the wrong problem correct and the customer is still unsatisfied. But it is an honest attempt at doing things correctly.

From â€œSocial Processes and Proofs of Theorems and Programs" by Lipton and Perlis, they talked about the reality that mathematical proof is not as rigorous and reliable as people outside of the mathematical community like to believe it is. \cite{lipton_social_1979} And this is a valid point. But I feel that there are two aspects to mathematical culture. There is the art side of mathematics, that is cultural and human and has many rituals that would be lost in automated systems. And then there is the engineering side of mathematics, the part of mathematics that likes to think of itself as a science. This later aspect is what people use to build bridges and dams. It would be nice if this area of math is reliable.

I also wanted to learn a programming language that is good for both verification of software and new mathematical theories. The Curry-Howard isomorphism is an exciting and useful fact. And to consider the future of mathematical research, in mathematical subjects like algebraic topology, it seems harder each decade to generate correct proofs in some areas. Categories just have more computation involved. Mathematicians can stick to the sidelines of what can be pictured on a chalkboard. But I find that kind of work to be less interesting. There are new heights to be reached, possibly faster, with new technology. And one of the more appealing attributes of mathematical results obtained this way, is the gap to implementation of an algorithm with such a construct is much smaller.

 Working on the Verified Software Toolchain (VST) seemed like a good opportunity to learn many complicated concepts as they are focused on a particular problem. There is practical use of logics, programming language design, automated reasoning, and practice with a type theory in a proving language. VST has some interesting features. It is written in Coq, a common language for writing proofs and some very sturdy code. There are over 300 proven packages offered in the Coq language on Opam, and the standard library looks pretty nice for using more advanced mathematics with code. \cite{noauthor_opam_nodate} These external packages include SMT solvers and cubical type theory, and the core language library includes various number and set constructions. Being able to use Reals instead of floating point numbers might seem excessive, but Real numbers are the minimum complete set. A lot of analysis concepts only approximately work on something weaker. 
 
 VST itself includes libraries used to reason about manual memory management at the proof level. I was curious about this. There are also packages in VST like VST-Floyd, and FCF, and Compcert. VST-Floyd automates reasoning around separation logic. The Foundational Cryptography Framework FCF is a bunch of complicated yet proven algorithms for encryption. And Compcert is a compiler from C to x86, ARM, and PowerPC that also uses separation logic to do so. In retrospect I should have worked on Compcert, as it is one of the most documented Coq programs in the VST.
